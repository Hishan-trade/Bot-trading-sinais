import asyncio
import os
import warnings
import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
from datetime import datetime, timezone
from telegram import Bot
from telegram.ext import Application, CommandHandler, ContextTypes
from io import BytesIO
import logging

matplotlib.use('Agg')
warnings.filterwarnings("ignore")
logging.basicConfig(level=logging.INFO)

# === CONFIGURA√á√ïES ===
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')  # Pega do Railway Variables
CHAT_ID = int(os.getenv('CHAT_ID'))  # Pega do Railway Variables

SYMBOLS = ["BTC-USD", "ETH-USD", "SOL-USD", "BNB-USD", "XRP-USD"]
TIMEFRAMES = {"4h": "4h", "1d": "1d"}
ANALYSIS_DELAY = 15 * 60  # 15 min

# === INDICADORES B√ÅSICOS ===
def rsi(close, window=14):
    delta = close.diff()
    gain = delta.where(delta > 0, 0).rolling(window).mean()
    loss = -delta.where(delta < 0, 0).rolling(window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def ema(series, window):
    return series.ewm(span=window, adjust=False).mean()

def macd(close):
    ema12 = ema(close, 12)
    ema26 = ema(close, 26)
    macd_line = ema12 - ema26
    signal = ema(macd_line, 9)
    return macd_line, signal

def atr(df, window=14):
    tr = pd.concat([
        df['High'] - df['Low'],
        (df['High'] - df['Close'].shift()).abs(),
        (df['Low'] - df['Close'].shift()).abs()
    ], axis=1).max(axis=1)
    return tr.rolling(window).mean()

# === NOVOS INDICADORES ===
def bollinger_bands(close, window=20, std=2):
    sma = close.rolling(window).mean()
    std_dev = close.rolling(window).std()
    upper = sma + (std_dev * std)
    lower = sma - (std_dev * std)
    return upper, sma, lower

def stochastic(df, k_window=14, d_window=3):
    low_min = df['Low'].rolling(k_window).min()
    high_max = df['High'].rolling(k_window).max()
    k = 100 * (df['Close'] - low_min) / (high_max - low_min)
    d = k.rolling(d_window).mean()
    return k, d

def adx(df, window=14):
    plus_di = 100 * (df['High'].diff().clip(lower=0).ewm(alpha=1/window).mean() /
                      atr(df, window))
    minus_di = 100 * (df['Low'].diff().clip(upper=0).abs().ewm(alpha=1/window).mean() /
                       atr(df, window))
    dx = (abs(plus_di - minus_di) / (plus_di + minus_di)) * 100
    return dx.ewm(alpha=1/window).mean()

def obv(df):
    obv = (np.sign(df['Close'].diff()) * df['Volume']).fillna(0).cumsum()
    return obv

# === DADOS ===
def get_data(symbol, tf, period="2y"):
    try:
        df = yf.download(symbol, period=period, interval=tf, progress=False, auto_adjust=True)
        if len(df) > 50:
            return df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
    except Exception as e:
        logging.error(f"Erro yfinance {symbol}: {e}")
    return None

# === ADICIONAR INDICADORES ===
def add_indicators(df):
    df = df.copy()
    df["RSI"] = rsi(df["Close"])
    df["MACD"], df["Signal"] = macd(df["Close"])
    df["EMA9"] = ema(df["Close"], 9)
    df["EMA21"] = ema(df["Close"], 21)
    df["EMA200"] = ema(df["Close"], 200)
    df["Vol_Mean"] = df["Volume"].rolling(20).mean()
    df["ATR"] = atr(df)
    df["BB_Upper"], df["BB_Mid"], df["BB_Lower"] = bollinger_bands(df["Close"])
    df["%K"], df["%D"] = stochastic(df)
    df["ADX"] = adx(df)
    df["OBV"] = obv(df)
    df["OBV_SMA"] = df["OBV"].rolling(20).mean()
    return df.dropna()

# === TRENDLINE BREAKOUT ===
def trend_break(df_slice, direction="buy"):
    try:
        c = df_slice["Close"].values
        x = np.arange(len(c))
        z = np.polyfit(x, c, 1)
        line = z[0] * x + z[1]
        if direction == "buy":
            return c[-1] > line[-1] and c[-2] <= line[-2]
        else:
            return c[-1] < line[-1] and c[-2] >= line[-2]
    except:
        return False

# === GR√ÅFICO DE SINAL ===
def plot_signal(df, symbol, tf, signal_type="buy"):
    plt.figure(figsize=(13, 7))
    r = df.tail(50)
    color = 'green' if signal_type == "buy" else 'red'
    label = 'COMPRA' if signal_type == "buy" else 'VENDA'
    arrow_color = 'lime' if signal_type == "buy" else 'red'
    marker_color = 'lime' if signal_type == "buy" else 'red'
    y_offset = 1.10 if signal_type == "buy" else 0.90

    plt.plot(r.index, r["Close"], label="Pre√ßo", color="black", linewidth=2)
    plt.plot(r.index, r["EMA9"], label="EMA9", color="blue", alpha=0.7)
    plt.plot(r.index, r["EMA21"], label="EMA21", color="orange", alpha=0.7)
    plt.plot(r.index, r["BB_Upper"], label="BB Upper", color="gray", linestyle="--", alpha=0.6)
    plt.plot(r.index, r["BB_Lower"], label="BB Lower", color="gray", linestyle="--", alpha=0.6)

    last = r.iloc[-1]
    plt.scatter([r.index[-1]], [last["Close"]], color=marker_color, s=140, zorder=5, edgecolors='black', linewidth=1.5)
    plt.annotate(label, xy=(r.index[-1], last["Close"]),
                 xytext=(r.index[-12], last["Close"] * y_offset),
                 arrowprops=dict(arrowstyle='->', color=arrow_color, lw=3),
                 fontsize=18, color=color, fontweight='bold', ha='center')

    plt.title(f"{symbol.replace('-USD', '')} - {label} ({tf})", fontsize=16, pad=20)
    plt.legend(fontsize=9, loc='upper left')
    plt.grid(alpha=0.3)
    plt.tight_layout()

    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=180, bbox_inches='tight')
    buf.seek(0)
    plt.close()
    return buf

# === GERAR SINAIS PARA BACKTEST ===
def generate_signals(df):
    df['Buy_Signal'] = 0
    df['Sell_Signal'] = 0

    for i in range(1, len(df)):
        r = df.iloc[i]
        prev = df.iloc[i-1]

        # COMPRA
        buy_count = 0
        if r["RSI"] < 40: buy_count += 1
        if r["MACD"] > r["Signal"] and prev["MACD"] <= prev["Signal"]: buy_count += 1
        if r["EMA9"] > r["EMA21"] > r["EMA200"]: buy_count += 1
        if r["Close"] <= r["BB_Lower"]: buy_count += 1
        if r["%K"] < 20 and r["%K"] > r["%D"]: buy_count += 1
        if trend_break(df.iloc[max(0, i-40):i], direction="buy"): buy_count += 1
        if r["Volume"] > r["Vol_Mean"] * 1.3: buy_count += 1
        if r["OBV"] > r["OBV_SMA"]: buy_count += 1

        # VENDA
        sell_count = 0
        if r["RSI"] > 60: sell_count += 1
        if r["MACD"] < r["Signal"] and prev["MACD"] >= prev["Signal"]: sell_count += 1
        if r["EMA9"] < r["EMA21"] < r["EMA200"]: sell_count += 1
        if r["Close"] >= r["BB_Upper"]: sell_count += 1
        if r["%K"] > 80 and r["%K"] < r["%D"]: sell_count += 1
        if trend_break(df.iloc[max(0, i-40):i], direction="sell"): sell_count += 1
        if r["Volume"] > r["Vol_Mean"] * 1.3: sell_count += 1
        if r["OBV"] < r["OBV_SMA"]: sell_count += 1

        # Filtro ADX
        if r["ADX"] < 25: continue

        if buy_count >= 2 and buy_count >= sell_count:
            df.at[df.index[i], 'Buy_Signal'] = 1
        elif sell_count >= 2:
            df.at[df.index[i], 'Sell_Signal'] = 1

    return df

# === BACKTEST ===
def backtest_strategy(symbol, tf, period="2y"):
    df = get_data(symbol, tf, period)
    if df is None or len(df) < 200: return None, None

    df = add_indicators(df)
    df = generate_signals(df)

    # Simula√ß√£o
    position = 0
    entry_price = 0
    trades = []
    df['Returns'] = df['Close'].pct_change()
    df['Strategy_Returns'] = 0.0
    df['Equity'] = 10000  # Inicial

    for i in range(1, len(df)):
        df.at[df.index[i], 'Equity'] = df.at[df.index[i-1], 'Equity']

        if df['Buy_Signal'].iloc[i] == 1 and position == 0:
            position = 1
            entry_price = df['Close'].iloc[i]
            trades.append({'Type': 'Buy', 'Price': entry_price, 'Date': df.index[i]})

        elif df['Sell_Signal'].iloc[i] == 1 and position == 1:
            exit_price = df['Close'].iloc[i]
            trade_return = (exit_price - entry_price) / entry_price
            df.at[df.index[i], 'Strategy_Returns'] = trade_return
            df.at[df.index[i], 'Equity'] *= (1 + trade_return)
            trades.append({'Type': 'Sell', 'Price': exit_price, 'Date': df.index[i], 'Return': trade_return})
            position = 0

    # M√©tricas
    total_return = (df['Equity'].iloc[-1] / 10000 - 1) * 100
    strategy_returns = df['Strategy_Returns'][df['Strategy_Returns'] != 0]
    win_rate = (strategy_returns > 0).mean() * 100 if len(strategy_returns) > 0 else 0
    num_trades = len(strategy_returns)
    sharpe = (strategy_returns.mean() / strategy_returns.std()) * np.sqrt(252 / (1 if tf == '1d' else 6)) if len(strategy_returns) > 1 else 0
    equity = df['Equity']
    drawdown = (equity / equity.cummax() - 1) * 100
    max_dd = drawdown.min()

    metrics_msg = (
        f"*Backtest: {symbol.replace('-USD', '')} ({tf})*\n"
        f"Per√≠odo: {period} | Trades: {num_trades}\n"
        f"Retorno Total: {total_return:.2f}%\n"
        f"Sharpe Ratio: {sharpe:.2f}\n"
        f"Max Drawdown: {max_dd:.2f}%\n"
        f"Win Rate: {win_rate:.1f}%\n"
        f"_{datetime.now(timezone.utc).strftime('%d/%m %H:%M')} UTC_"
    )

    # Plot
    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['Equity'], label='Equity Curve', color='blue')
    buys = df[df['Buy_Signal'] == 1]
    sells = df[df['Sell_Signal'] == 1]
    plt.scatter(buys.index, buys['Equity'], marker='^', color='green', s=100, label='Buy')
    plt.scatter(sells.index, sells['Equity'], marker='v', color='red', s=100, label='Sell')
    plt.title(f"Backtest Equity Curve - {symbol} ({tf})")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.tight_layout()
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=150)
    buf.seek(0)
    plt.close()
    return metrics_msg, buf

# === AN√ÅLISE POR TF ===
def analyze_tf(symbol, tf):
    df = get_data(symbol, tf)
    if df is None or len(df) < 200: return None
    df = add_indicators(df)
    if len(df) == 0: return None

    r = df.iloc[-1]
    prev = df.iloc[-2]

    buy_signals = []
    if r["RSI"] < 40: buy_signals.append("RSI < 40")
    if r["MACD"] > r["Signal"] and prev["MACD"] <= prev["Signal"]: buy_signals.append("MACD Cruzou ‚Üë")
    if r["EMA9"] > r["EMA21"] > r["EMA200"]: buy_signals.append("EMAs ‚Üë")
    if r["Close"] <= r["BB_Lower"]: buy_signals.append("Toca BB Inferior")
    if r["%K"] < 20 and r["%K"] > r["%D"]: buy_signals.append("Stoch Oversold")
    if trend_break(df.tail(40), direction="buy"): buy_signals.append("Breakout ‚Üë")
    if r["Volume"] > r["Vol_Mean"] * 1.3: buy_signals.append("Volume +30%")
    if r["OBV"] > r["OBV_SMA"]: buy_signals.append("OBV ‚Üë")

    sell_signals = []
    if r["RSI"] > 60: sell_signals.append("RSI > 60")
    if r["MACD"] < r["Signal"] and prev["MACD"] >= prev["Signal"]: sell_signals.append("MACD Cruzou ‚Üì")
    if r["EMA9"] < r["EMA21"] < r["EMA200"]: sell_signals.append("EMAs ‚Üì")
    if r["Close"] >= r["BB_Upper"]: sell_signals.append("Toca BB Superior")
    if r["%K"] > 80 and r["%K"] < r["%D"]: sell_signals.append("Stoch Overbought")
    if trend_break(df.tail(40), direction="sell"): sell_signals.append("Breakout ‚Üì")
    if r["Volume"] > r["Vol_Mean"] * 1.3: sell_signals.append("Volume +30%")
    if r["OBV"] < r["OBV_SMA"]: sell_signals.append("OBV ‚Üì")

    if r["ADX"] < 25: return None

    if len(buy_signals) >= 2 and len(buy_signals) >= len(sell_signals):
        strength = "FORTE" if len(buy_signals) >= 4 else "MODERADO"
        sl = r["Close"] - 2 * r["ATR"]
        tp = r["Close"] + 3 * r["ATR"]
        signals = buy_signals
        signal_type = "buy"
    elif len(sell_signals) >= 2:
        strength = "FORTE" if len(sell_signals) >= 4 else "MODERADO"
        sl = r["Close"] + 2 * r["ATR"]
        tp = r["Close"] - 3 * r["ATR"]
        signals = sell_signals
        signal_type = "sell"
    else:
        return None

    rr = round(abs(tp - r["Close"]) / abs(r["Close"] - sl), 2)
    action = "COMPRA" if signal_type == "buy" else "VENDA"
    emoji = "üìà" if signal_type == "buy" else "üìâ"

    msg = (
        f"*{strength} ‚Üí {symbol.replace('-USD', '')} ({tf}) {action}*\n"
        f"üí∞ Pre√ßo: `${r['Close']:,.2f}`\n"
        f"üìä RSI: `{r['RSI']:.1f}` | Stoch: `{r['%K']:.1f}` | ADX: `{r['ADX']:.1f}`\n"
        f"üìà Volume: +{((r['Volume']/r['Vol_Mean'])-1)*100:.1f}%\n"
        f"üõë SL: `${sl:,.2f}` | üéØ TP: `${tp:,.2f}` | R:R `1:{rr}`\n"
        f"‚úÖ Sinais ({len(signals)}): {' | '.join(signals[:5])}{'...' if len(signals)>5 else ''}\n"
        f"_{datetime.now(timezone.utc).strftime('%d/%m %H:%M')} UTC_ {emoji}"
    )

    chart = plot_signal(df, symbol, tf, signal_type)
    return msg, chart, strength, signal_type

# === AN√ÅLISE TOTAL ===
async def full_analysis():
    results = []
    for s in SYMBOLS:
        for tf in TIMEFRAMES.values():
            res = analyze_tf(s, tf)
            if res:
                results.append(res)
    return results

# === ENVIO ===
async def send_signal(text, chart):
    try:
        await application.bot.send_photo(chat_id=CHAT_ID, photo=chart, caption=text, parse_mode='Markdown')
        logging.info(f"Sinal enviado: {text.splitlines()[0]}")
    except Exception as e:
        logging.error(f"Erro envio: {e}")
        try:
            await application.bot.send_message(CHAT_ID, text, parse_mode='Markdown')
        except: pass

# === COMANDOS ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Bot Avan√ßado com Backtest ATIVO!\nUse /sinais ou /backtest SYMBOL TF", parse_mode='Markdown')

async def sinais(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("An√°lise avan√ßada em andamento...")
    results = await full_analysis()
    if not results:
        await update.message.reply_text("Nenhum sinal forte.")
        return
    for msg, chart, strength, _ in results:
        if strength == "FORTE":
            await send_signal(msg, chart)
            await asyncio.sleep(3)

async def backtest_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if len(args) != 2:
        await update.message.reply_text("Uso: /backtest SYMBOL TF (ex: /backtest BTC-USD 1d)")
        return
    symbol, tf = args
    if tf not in TIMEFRAMES.values():
        await update.message.reply_text("TF inv√°lido. Use 4h ou 1d.")
        return

    await update.message.reply_text(f"Rodando backtest para {symbol} {tf}...")
    msg, chart = backtest_strategy(symbol, tf)
    if msg:
        await send_signal(msg, chart)
    else:
        await update.message.reply_text("Erro no backtest. Dados insuficientes.")

# === LOOP AUTOM√ÅTICO ===
async def auto_loop():
    await asyncio.sleep(10)
    await application.bot.send_message(CHAT_ID, "Bot Avan√ßado iniciado! An√°lise a cada 15 min.")
    sent = set()
    while True:
        try:
            results = await full_analysis()
            for msg, chart, strength, stype in results:
                sid = f"{msg.split('‚Üí')[1].split('(')[0].strip()}_{stype}_{strength}"
                if strength == "FORTE" and sid not in sent:
                    await send_signal(msg, chart)
                    sent.add(sid)
                    await asyncio.sleep(3)
            if len(sent) > 100: sent.clear()
            await asyncio.sleep(ANALYSIS_DELAY)
        except Exception as e:
            logging.error(f"Loop error: {e}")
            await asyncio.sleep(60)

# === MAIN ===
async def main():
    global application
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("sinais", sinais))
    application.add_handler(CommandHandler("backtest", backtest_command))
    
    asyncio.create_task(auto_loop())
    
    logging.info("Bot iniciado no Railway!")
    await application.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    asyncio.run(main())
  Adiciona o c√≥digo principal do bot
